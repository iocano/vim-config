
" {{{ Return git tree root if exists, otherwise return empty string
function! g:GetGitRoot()

    " {{{ command description
    "   git :               Git command
    "   rev-parse :         Is an ancillary plumbing command primarily used for manipulation.
    "   --show-toplevel :   Show the path of the top-level directory of the working tree.
    "   2> /dev/null :      if not working tree git report and error, discard it
    " }}}
    let get_git_root_cmd = 'git rev-parse --show-toplevel 2> /dev/null'

    " execute command
    let cmd_output = system(get_git_root_cmd)

    " return command output
    return cmd_output[:-2] "[:-2] : Remove last byte from the string (^@)

endfunction
" }}}

" {{{ Return custom fold text (set with 'foldtext' option)
function! g:MyFoldText()

    " number of lines of current fold
    let line_count = v:foldend - v:foldstart + 1

    " singular/plural
    let singular_plural = (line_count == 1) ? 'line' : 'lines'

    " line to show when is not a function fold
    let first_no_empty_line = ''

    " iterate over all fold lines
    for i in range(v:foldstart, v:foldend)

        let current_line = copy(getline(i))

        " is a function fold: return function signature
        if current_line =~  '^ *function.*\(.*\)'
            return printf('+ %s -> %s %s ', current_line, line_count, singular_plural)
        endif

        " if not a function fold: get text of first line with text
        if ((current_line =~ '.*[a-zA-Z0-9]\+.*') && (first_no_empty_line == ''))
            let first_no_empty_line = current_line
        endif

    endfor

    " remove fold marks '{', comment mark '"' and white spaces
    let clean_line = substitute(first_no_empty_line, '\v( *[\{]{3} *)| *" *', '', "g")

    " if not a function return first no empty line
    return printf('+ %s -> %s %s', clean_line, line_count, singular_plural)

endfunction
" }}}

" {{{ Return 1 if plugin is loaded, otherwise return 0
function! g:PlugLoaded(name)

    " plugins manually installed
    let unplugged_dir = printf('%s/unplugged/%s', g:vim_dir, a:name)

    " plugin manager default dir
    let plugged_dir = printf('%s/plugged/%s', g:vim_dir, a:name)

    " name is dir/plugin name and exists on runtimepath
    return (isdirectory(unplugged_dir) || isdirectory(plugged_dir)) && match(&runtimepath, a:name) != -1

endfunction
"}}}

" {{{ Load list of files
function! g:SourceFileList(file_list)

    for file in a:file_list

        execute printf('source %s/%s', g:vim_dir, file)

    endfor

endfunction
" }}}

" {{{
function! g:GetVimInfoFile()
    let file_name = has('nvim') ? 'nviminfo' : 'viminfo'
    let full_path = printf("%s/%s", g:vim_dir, file_name)

    let create_file_cmd = has('unix') ? "touch" : "echo '' >"

    if !filereadable(full_path)
        silent execute printf("!%s %s", create_file_cmd, full_path)
    endif

    return substitute(full_path, '\\', '/', "g")

endfunction
" }}}

" {{{ Create a directory
function! g:CreateDirectoryIfNotExists(directory)

    if isdirectory(a:directory) | return | endif

    if has('win32') || has('win64')
        silent execute printf("!mkdir %s", substitute(a:directory, "/" , "\\", "g"))
    else
        silent execute printf("!mkdir %s", a:directory)
    endif
endfunction
" }}}

" {{{ Get plug manager
function! g:InstallPluginManager()

    let s:plug_destination = printf('%s/autoload/plug.vim', g:vim_dir)

    let s:plug_source = "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"

    let s:curl_command = printf('curl -fLo %s --create-dirs %s', s:plug_destination, s:plug_source)

    call system(s:curl_command)

endfunction
" }}}

" {{{ Program plugins install on VimEnter event
function! g:InstallPlugins()

    " clean terminal
    execute "!clear"

    "install plugins
    PlugInstall --sync

    " close installation buffer
    bd

endfunction
" }}}

" {{{ Grab a font by url using curl and install
function! g:InstallFontList(fonts_url, font_path_list)

    let font_destination = expand('~/.local/share/fonts')

    " create dir if no exists
    call system(printf('mkdir -p %s', font_destination))

    " to save font names installed
    let font_name_list = []

    for font_path in a:font_path_list

        let font_url = printf("%s/%s", url, font_path_list)
        let font_name = s:InstallFont(font_url, font_destination)

        call add(font_name_list, font_name)

    endfor

    return font_name_list

endfunction
" }}}

" {{{
function! s:InstallFont(font_url, font_destination)

    " get font name from url
    let url_font_name = split(a:font_url, '/')[-1]

    " 'decode' url font name
    let font_name = substitute(url_font_name, '%20', ' ', 'g')

    " get font from url
    call system(printf("curl -fLo '%s/%s' %s", a:font_destination, font_name, fnameescape(a:font_url)))

    return font_name

endfunction
" }}}

" {{{ Execute command to update font cache
function! g:UpdateFontCache()

    " {{{ command description
    " sudo: ....
    "   -k: remove timestamp (always request password)
    " fc-cache: update font cache
    "   -f: force
    "   -v: verbose
    " }}}
    let update_font_cache_cmd = 'sudo -k fc-cache -fv'

    echo "Input password to update font cache"
    echo printf("Or updte later with: %s\n", substitute(update_font_cache_cmd, " -k", '', ''))
    call feedkeys("\<CR>")

    call system(update_font_cache_cmd)

endfunction
" }}}

" {{{ Restart vim
function! g:RestartVim()

    " command to get vim plus arguments (e.g. vim -O file1 file2 ...)
    let get_vim_args_cmd = printf("ps -o command= -p %s", getpid())

    " get command output
    let start_vim_cmd = system(get_vim_args_cmd)

    " command to sleep 1 second, start vim with args and finally clear screen on exit
    let schedule_restart_cmd = printf('!sleep 1 && %s', start_vim_cmd)

    " execute command
    execute schedule_restart_cmd

    " clean terminal
    execute "!clear"

    " exit vim
    :qall!

endfunction
" }}}

" {{{
function! g:InstallCocExtensionList(extension_list)
    for extension in a:extension_list
        execute printf('CocInstall %s', extension)
    endfor
endfunction
" }}}

